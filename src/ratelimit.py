# src/ratelimit.py
import time
from collections import deque
from typing import Dict, Deque


# simple in-memory sliding window
_buckets: Dict[str, Deque[float]] = {}


def _allow(key: str, limit: int, window_sec: int) -> bool:
    now = time.time()
    dq = _buckets.setdefault(key, deque())
    # drop old
    while dq and now - dq[0] > window_sec:
        dq.popleft()
    if len(dq) >= limit:
        return False
    dq.append(now)
    return True


class RateLimitExceeded(Exception):
    pass


def check_rate(key: str, limit: int, window_sec: int):
    if not _allow(key, limit, window_sec):
        raise RateLimitExceeded(f"Rate limit exceeded: {limit}/{window_sec}s")


# ====== Wallet + Daily DTOs (already used elsewhere / generated by Codegen) ======
from typing import List, Optional
from pydantic import BaseModel, Field


class WalletSummarySchema(BaseModel):
    balance_cents: int
    available_cents: int
    on_hold_cents: int
    locked_reserve_cents: int
    tier: int
    trust_score: float


class WalletLimitsSchema(BaseModel):
    can_withdraw: bool
    min_cents: int
    max_cents_now: int
    attempts_left: int
    cooldown_seconds: int
    explain: str
    reasons: List[str] = []
    tier: int
    trust_score: float


class WithdrawCreate(BaseModel):
    amount_cents: int = Field(
        ...,
        ge=100,  # at least $1 unless config says $5; validated again in logic
    )
    dst_kind: str  # "bank" | "wallet" | "store"
    dst_account: str
    country: str
    device_fp: str
    face_image_b64: str


# <<< CODEGEN:DAILY START
class TaskDTO(BaseModel):
    id: str
    title: str
    usd: float
    payload: dict = {}
    limits: dict = {}
    assist: dict | None = None


class SubmitDTO(BaseModel):
    task_id: str
    answer: dict
    elapsed_ms: int = 0


class SubmitResult(BaseModel):
    ok: bool
    usd_credited: float = 0.0
    next_hint: Optional[str] = None
    new_balance_usd: float = 0.0
# <<< CODEGEN:DAILY END
